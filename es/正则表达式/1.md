# 正则表达式字符串匹配

正则表达式是匹配模式，要么匹配字符，要么匹配位置。

内容提要：

- 两种模糊匹配
- 字符组
- 量词
- 分支解构

## 1.1.两种模糊匹配

1. 横向模糊匹配
2. 纵向模糊匹配

### 1. 横向模糊匹配

横向匹配指的是：一个正则可以匹配的字符串的长度不是固定的，可以是多种情况。

实现方式是使用量词。比如：`{m,n}`，表示连续出现最少`m`次，最多`n`次。

比如：

```js
/ab{2,5}c/;
```

> 表示第一个字符是`a`，接下来是 2 到 5 个字符`b`，最后一个字符是`c`。

但是上面的这个正则匹配只会匹配第一个匹配的值：

```js
const str = "abc abbc abbbc";
const res = str.match(/ab{1,5}c/);
console.log(res); // ["abc"]

// 如果加上 /g 表示全局匹配，会匹配所有符合条件的字符
const str = "abc abbc abbbc";
const res = str.match(/ab{1,5}c/g);
console.log(res); // [ 'abc', 'abbc', 'abbbc' ]
```

### 2. 纵向模糊匹配

纵向模糊匹配指的是：一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。

实现方式是使用字符组。比如`[abc]`，表示该字符可以是`a`、`b`、`c`中的任何一个。

```js
const regex = /a[123]b/g;
const str = "a0b a1b a2b a3b a4b";
console.log(str.match(regex)); // [ 'a1b', 'a2b', 'a3b' ]
```

## 1.2.字符组

> 字符组虽然叫组，但是其实只是一个字符

例如`[abc]`就是一个字符组，但是它只会匹配`a`、`b`、`c`中的其中一个。

### 1. 范围表示法

如果字符组里的字符很多，比如字符组里有 26 个字母，`[abcdef...]`这种写法就很繁琐，所以可以使用范围的写法，改写成`[a-z]`。

```js
/[abcdefghijklmnopqrstuvwxyz]/
// 改写成
/[a-z]/

/[123456abcdefgABCDEFG]/
// 改写成
/[1-6a-gA-G]/
```

如果组里面有`-`，则用转义符号`\`来转义。

```js
/[1\-6]/;
```
