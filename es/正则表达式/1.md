# 正则表达式字符串匹配

正则表达式是匹配模式，要么匹配字符，要么匹配位置。

内容提要：

- 两种模糊匹配
- 字符组
- 量词
- 分支解构

## 1.1.两种模糊匹配

1. 横向模糊匹配
2. 纵向模糊匹配

### 1. 横向模糊匹配

横向匹配指的是：一个正则可以匹配的字符串的长度不是固定的，可以是多种情况。

实现方式是使用量词。比如：`{m,n}`，表示连续出现最少`m`次，最多`n`次。

比如：

```js
/ab{2,5}c/;
```

> 表示第一个字符是`a`，接下来是 2 到 5 个字符`b`，最后一个字符是`c`。

但是上面的这个正则匹配只会匹配第一个匹配的值：

```js
const str = "abc abbc abbbc";
const res = str.match(/ab{1,5}c/);
console.log(res); // ["abc"]

// 如果加上 /g 表示全局匹配，会匹配所有符合条件的字符
const str = "abc abbc abbbc";
const res = str.match(/ab{1,5}c/g);
console.log(res); // [ 'abc', 'abbc', 'abbbc' ]
```

### 2. 纵向模糊匹配

纵向模糊匹配指的是：一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。

实现方式是使用字符组。比如`[abc]`，表示该字符可以是`a`、`b`、`c`中的任何一个。

```js
const regex = /a[123]b/g;
const str = "a0b a1b a2b a3b a4b";
console.log(str.match(regex)); // [ 'a1b', 'a2b', 'a3b' ]
```

## 1.2.字符组

> 字符组虽然叫组，但是其实只是一个字符

例如`[abc]`就是一个字符组，但是它只会匹配`a`、`b`、`c`中的其中一个。

### 1. 范围表示法

如果字符组里的字符很多，比如字符组里有 26 个字母，`[abcdef...]`这种写法就很繁琐，所以可以使用范围的写法，改写成`[a-z]`。

```js
/[abcdefghijklmnopqrstuvwxyz]/
// 改写成
/[a-z]/

/[123456abcdefgABCDEFG]/
// 改写成
/[1-6a-gA-G]/
```

如果组里面有`-`，则用转义符号`\`来转义。

```js
/[1\-6]/;
```

### 2. 排除字符组

排除字符组就是对字符组的取反，比如`[^abc]`就是`[abc]`的取反。

### 3. 常见的简写形式

有了字符组的概念之后，一些常见的符号我们也就能理解了。

| 字符组 | 具体含义                                                                               |
| ------ | -------------------------------------------------------------------------------------- |
| \d     | 表示[0-9]，表示是一位数字                                                              |
| \D     | 表示[^\d]或者[^0-9]。表示除数字以外的任意字符                                          |
| \w     | 表示[0-9a-zA-Z_]。表示数字，大小写字母和下划线                                         |
| \W     | 表示[^0-9a-za-z_]。表示非数字，大小写字母和下划线                                      |
| \s     | 表示[\t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符 |
| \S     | 表示[^\t\v\n\r\f]                                                                      |
| .      | 通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。                     |

> 如果要匹配任意字符怎么办？可以使用 `[\d\D]`、`[\w\W]`、`[\s\S]` 和 `[^]` 中任何的一个。

## 1.3.量词

### 1.简写形式

量词也称重复。

| 量词 | 具体含义                            |
| ---- | ----------------------------------- |
| {m,} | 表示至少出现 m 次                   |
| {m}  | 表示出现 m 次，等价于{m,m}          |
| ?    | 等价于{0,1}，表示出现 0 次或者 1 次 |
| +    | 等价于{1,}，表示至少出现 1 次       |
| \*   | 等价于{0,}，表示出现或者不出现      |

### 2.贪婪匹配与惰性匹配

```js
const regex = /\d{2,5}/g;
const string = "123 1234 12345 123456";
console.log(string.match(regex)); // [ '123', '1234', '12345', '12345' ]
```

其中正则`/d{2,5}/g`表示数字连续出现 2 到 5 次。对匹配 2 位、3 位、4 位、5 位连续的数字。

但是它全局匹配是贪婪的，它会尽可能多的匹配。比如上面的例子中，`123`这个字符串，其实`12`就已经符合正则的条件了，但是因为后面的`3`跟`12`连续，并且加上`3`以后，仍然符合正则的规则，所以会匹配到`123`而不是`12`。

总结下来一句话，就是在符合正则规则的前提下，尽可能多的匹配字符。

将上面的贪婪匹配改写成惰性匹配：

```js
const regex = /\d{2,5}?/g;
const string = "123 1234 12345 123456";
console.log(string.match(regex)); // ['12', '12', '34','12', '34', '12','34', '56']
```

惰性匹配是只要匹配到符合条件的字符就可以了，不会去考虑再多匹配一个字符，是否还是可以满足条件。

| 惰性量词 | 贪婪量词 |
| -------- | -------- |
| {m,n}?   | {m,n}    |
| {m,}?    | {m,}     |
| ??       | ?        |
| +?       | +        |
| \*?      | \*       |

## 1.4.多选分支

一个模式可以实现横向和纵向匹配。而多选分支可以支持多个子模式任选其一。

例如：

```js
const regex = /nice|good/g;
const str = "nice 啊 小伙子，good";
console.log(str.match(regex)); //[ 'nice', 'good' ]
```

但是如果是下面这种情况，就只会匹配一个：

```js
const regex = /goodbye|good/g;
const str = "goodbye";
console.log(str.match(regex)); // [ 'goodbye' ]
// 调换位置
const regex = /good|goodbye/g;
const str = "goodbye";
console.log(str.match(regex)); // [ 'good' ]
```

说明分支结构是惰性匹配，当前面的匹配上了，就不会去尝试后面的了。

> 但是也可以理解成，当前面匹配了以后，字符串的 `good` 已经被占了，就剩下 `bye` 跟 `goodbye` 匹配了，当然匹配不上了。
