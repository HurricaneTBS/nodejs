# 正则表达式字符串匹配

正则表达式是匹配模式，要么匹配字符，要么匹配位置。

内容提要：

- 两种模糊匹配
- 字符组
- 量词
- 分支解构

## 1.1.两种模糊匹配

1. 横向模糊匹配
2. 纵向模糊匹配

### 1. 横向模糊匹配

横向匹配指的是：一个正则可以匹配的字符串的长度不是固定的，可以是多种情况。

实现方式是使用量词。比如：`{m,n}`，表示连续出现最少`m`次，最多`n`次。

比如：

```js
/ab{2,5}c/;
```

> 表示第一个字符是`a`，接下来是 2 到 5 个字符`b`，最后一个字符是`c`。

但是上面的这个正则匹配只会匹配第一个匹配的值：

```js
const str = "abc abbc abbbc";
const res = str.match(/ab{1,5}c/);
console.log(res); // ["abc"]

// 如果加上 /g 表示全局匹配，会匹配所有符合条件的字符
const str = "abc abbc abbbc";
const res = str.match(/ab{1,5}c/g);
console.log(res); // [ 'abc', 'abbc', 'abbbc' ]
```

### 2. 纵向模糊匹配

纵向模糊匹配指的是：一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。

实现方式是使用字符组。比如`[abc]`，表示该字符可以是`a`、`b`、`c`中的任何一个。

```js
const regex = /a[123]b/g;
const str = "a0b a1b a2b a3b a4b";
console.log(str.match(regex)); // [ 'a1b', 'a2b', 'a3b' ]
```

## 1.2.字符组

> 字符组虽然叫组，但是其实只是一个字符

例如`[abc]`就是一个字符组，但是它只会匹配`a`、`b`、`c`中的其中一个。

### 1. 范围表示法

如果字符组里的字符很多，比如字符组里有 26 个字母，`[abcdef...]`这种写法就很繁琐，所以可以使用范围的写法，改写成`[a-z]`。

```js
/[abcdefghijklmnopqrstuvwxyz]/
// 改写成
/[a-z]/

/[123456abcdefgABCDEFG]/
// 改写成
/[1-6a-gA-G]/
```

如果组里面有`-`，则用转义符号`\`来转义。

```js
/[1\-6]/;
```

### 2. 排除字符组

排除字符组就是对字符组的取反，比如`[^abc]`就是`[abc]`的取反。

### 3. 常见的简写形式

有了字符组的概念之后，一些常见的符号我们也就能理解了。

| 字符组 | 具体含义                                                                               |
| ------ | -------------------------------------------------------------------------------------- |
| \d     | 表示[0-9]，表示是一位数字                                                              |
| \D     | 表示[^\d]或者[^0-9]。表示除数字以外的任意字符                                          |
| \w     | 表示[0-9a-zA-Z_]。表示数字，大小写字母和下划线                                         |
| \W     | 表示[^0-9a-za-z_]。表示非数字，大小写字母和下划线                                      |
| \s     | 表示[\t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符 |
| \S     | 表示[^\t\v\n\r\f]                                                                      |
| .      | 通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。                     |
