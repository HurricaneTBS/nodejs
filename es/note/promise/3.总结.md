## `Promise`的主要使用

### 回调函数

回调函数一直是`JavaScript`中比较令人纠结的写法，主要场景是用于处理并列或者并行的操作，然后在回调函数中处理操作的结果。这样的原生写法会带来如下不便：

1. 回调状态不便管理
2. 回调方式自由松散，没有约束

例如下面的回调写法：

```js
function func(num, callback) {
  setTimeout(() => {
    try {
      let result = num * 20;
      callback(result, null);
    } catch (e) {
      callback(null, e);
    }
  }, 2000);
}

function callback(result, error) {
  if (error) {
    console.log(error);
  } else {
    console.log(result);
  }
}

func(20, callback); // 400
```

上面的代码中，如果要处理回调的结果`result`和`error`就必须在回调函数内处理：

```js
function callback(result, error) {
  if (error) {
    console.log(error);
  } else {
    //   在这里处理回调函数的结果
    if (result > 300) {
      console.log("你的分数太高了");
    } else {
      console.log("分数不行啊");
    }
    console.log(result);
  }
}
```

而我们希望的是在外面去处理结果，像这样：

```js
function func(num, callback) {
  //   ......
}

const result = func(num, callback);
// 接下来去处理result的数据

try {
  console.log(result);
} catch (e) {
  console.log(e);
}
```

要想避免使用回调函数，就可以使用`Promise`。


### `Promise`避免回调函数

使用Promise改写上面的代码：

```js
function func(num) {
  return new Promise((resolve) => {
    setTimeout(() => {
      let result = 1 / num;
      resolve(result);
    }, 2000);
  });
}

func(20).then(value=>console.log(value))
```

虽然这并没有实现直接处理结果，但是这已经进步了一大步了。

### await/async

对于回调来讲，`Promise`的到来看似解决了回调场景中的状态处理问题，但是`JavaScript`中令人头疼的不是回调，而是`回调嵌套`，而`Promise`也不能彻底解决回调嵌套带来的代码维护以及可读性的问题。

#### 原生回调嵌套

```js
function increase(num, callback) {
   setTimeout(() => {
     if( !(num >= 0) ) {
       callback(new Error('The parameters must be greater than zero'), null)
     } else {
      let result = num + 1;
      callback(null, result);
     }
   }, 100)
}

increase(1, (err, result1) => {
  if(!err) {
    console.log(`result1 = ${result1}`)
    
    increase(result1, (err, result2) => {
      if(!err) {
        console.log(`result2 = ${result2}`)
        
        increase(result2, (err, result3) => {
          if(!err) {
            console.log(`result3 = ${result3}`)
          } else {
            console.log(err)
          }
        })
      } else {
        console.log(err)
      }
    })
  } else {
    console.log(err)
  }
})
// 运行结果
// "result1 = 2"
// "result1 = 3"
// "result1 = 4"
```

#### Promise 处理回调嵌套

```js
function increase(num) {
   return new Promise((resolve, reject) => {
      setTimeout(() => {
       if( !(num >= 0) ) {
         reject(new Error('The parameters must be greater than zero'))
       } else {
        let result = num + 1;
        resolve(result);
       }
     }, 100)
   })
}


increase(1).then((result1) => {
  console.log(`result1 = ${result1}`)
  
  increase(result1).then((result2) => {
    console.log(`result2 = ${result2}`)
    
    increase(result2).then((result3) => {
      console.log(`result3 = ${result3}`)
    }).catch(err => console.log(err));
    
  }).catch(err => console.log(err));
  
}).catch(err => console.log(err));
// 运行结果
// "result1 = 2"
// "result1 = 3"
// "result1 = 4"
```

看起来只是把回调的代码换了个位置。

#### aysnc/await的使用

- async 是 声明 在回调环境函数
- await 是 运行 在等待回调结果过程中
- Promise 是封装了回调操作的 原子任务

```js
// 封装原子任务
function increase(num) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if( !(num >= 0) ) {
        reject(new Error('The parameters must be greater than zero'))
      } else {
        resolve(num + 1)
      }

    }, 100);
  }).catch(err => console.log(err))
  
}

// 声明任务环境
async function envIncrease() {
  let num = 1;
  // 等待回调任务结果1返回
  let result1 = await increase(num);
  console.log(`result1 = ${result1}`);
  
  // 等待回调任务结果2返回
  let result2 = await increase(result1);
  console.log(`result2 = ${result2}`);
  
  // 等待回调任务结果3返回
  let result3 = await increase(result2);
  console.log(`result3 = ${result3}`);
  
  return result3
}

// 声明任务环境
async function env() {
  // 等待 环境 Increase 的结果返回
  let result = await envIncrease()
  console.log(`result = ${result}`);
}

// 运行环境
env()



// 运行结果
// "result1 = 2"
// "result1 = 3"
// "result1 = 4"
```